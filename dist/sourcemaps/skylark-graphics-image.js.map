{"version":3,"sources":["skylark-graphics-image.js"],"names":["define","skylark","attach","BaseException","binary","jpeg","JpegError","[object Object]","msg","super","DNLMarkerError","message","scanLines","this","EOIMarkerError","dctZigZag","Uint8Array","dctCos1","dctSin1","dctCos3","dctSin3","dctCos6","dctSin6","dctSqrt2","dctSqrt1d2","JpegImage","decodeTransform","colorTransform","_decodeTransform","_colorTransform","buildHuffmanTable","codeLengths","values","i","j","k","code","length","push","children","index","q","p","pop","getBlockBufferOffset","component","row","col","blocksPerLine","decodeScan","data","offset","frame","components","resetInterval","spectralStart","spectralEnd","successivePrev","successive","parseDNLMarker","mcusPerLine","progressive","startOffset","bitsData","bitsCount","readBit","nextByte","readUint16","maybeScanLines","blockRow","precision","Math","round","toString","decodeHuffman","tree","node","receive","n","receiveAndExtend","eobrun","successiveACNextValue","successiveACState","decodeMcu","decode","mcu","mcuRow","mcuCol","v","blockCol","h","blockOffset","decodeBlock","decodeFn","componentsLength","t","huffmanTableDC","diff","blockData","pred","e","rs","huffmanTableAC","s","r","z","offsetZ","sign","fileMarker","mcuExpected","blocksPerColumn","mcusPerColumn","mcuToRead","min","findNextFileMarker","invalid","partialMsg","sutil","warn","marker","quantizeAndInverse","blockBufferOffset","v0","v1","v2","v3","v4","v5","v6","v7","p0","p1","p2","p3","p4","p5","p6","p7","qt","quantizationTable","buildComponentData","computationBuffer","Int16Array","currentPos","startPos","maxPos","newPos","currentMarker","newMarker","prototype","dnlScanLines","readDataBlock","endOffset","array","subarray","prepareComponents","ceil","samplesPerLine","maxH","maxV","blocksPerLineForMcu","blocksPerColumnForMcu","blocksBufferSize","jfif","adobe","numSOSMarkers","quantizationTables","huffmanTablesAC","huffmanTablesDC","markerLoop","l","appData","version","major","minor","densityUnits","xDensity","yDensity","thumbWidth","thumbHeight","thumbData","flags0","flags1","transformCode","quantizationTablesLength","quantizationTablesEnd","quantizationTableSpec","tableData","Uint16Array","extended","sofScanLines","componentIds","componentId","componentsCount","qId","quantizationId","huffmanLength","huffmanTableSpec","codeLengthSum","huffmanValues","selectorsCount","componentIndex","tableSpec","successiveApproximation","processed","ex","parse","nextFileMarker","width","height","output","scaleX","scaleY","numComponents","isSourcePDF","componentScaleX","componentScaleY","blocksPerScanline","x","y","dataLength","Uint8ClampedArray","xScaleBlockOffset","Uint32Array","lastComponentScaleX","transform","Int32Array","_isColorConversionNeeded","_convertYccToRgb","Y","Cb","Cr","_convertYcckToRgb","_convertYcckToCmyk","_convertCmykToRgb","c","m","forceRGB","PDFJSDev","test","assert","_getLinearizedBlockData","rgbData","grayColor","shadow","DecodeStream","JpegStream","stream","maybeLength","dict","params","ch","getByte","skip","call","Object","create","defineProperty","get","getBytes","configurable","ensureBuffer","requested","readBlock","eof","jpegOptions","undefined","decodeArr","getArray","Array","isArray","bitsPerComponent","decodeArrLength","transformNeeded","maxValue","Number","isInteger","jpegImage","bytes","getData","drawWidth","drawHeight","buffer","bufferLength","main"],"mappings":"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","file":"../skylark-graphics-image.js","sourcesContent":["define('skylark-graphics-image/jpeg',[\r\n  \"skylark-langx-ns\"\r\n],function(skylark){\r\n  'use strict';\r\n\r\n  return skylark.attach(\"graphics.jpeg\");\r\n});\ndefine('skylark-graphics-image/jpeg-image',[\r\n    \"skylark-langx-exceptions/base-exception\",\r\n    'skylark-langx-binary',\r\n    \"./jpeg\"\r\n], function (BaseException, binary,jpeg) {\r\n    'use strict';\r\n    class JpegError extends BaseException {\r\n        constructor(msg) {\r\n            super(`JPEG error: ${ msg }`);\r\n        }\r\n    }\r\n    class DNLMarkerError extends BaseException {\r\n        constructor(message, scanLines) {\r\n            super(message);\r\n            this.scanLines = scanLines;\r\n        }\r\n    }\r\n    class EOIMarkerError extends BaseException {\r\n    }\r\n\r\n    var dctZigZag = new Uint8Array([\r\n        0,\r\n        1,\r\n        8,\r\n        16,\r\n        9,\r\n        2,\r\n        3,\r\n        10,\r\n        17,\r\n        24,\r\n        32,\r\n        25,\r\n        18,\r\n        11,\r\n        4,\r\n        5,\r\n        12,\r\n        19,\r\n        26,\r\n        33,\r\n        40,\r\n        48,\r\n        41,\r\n        34,\r\n        27,\r\n        20,\r\n        13,\r\n        6,\r\n        7,\r\n        14,\r\n        21,\r\n        28,\r\n        35,\r\n        42,\r\n        49,\r\n        56,\r\n        57,\r\n        50,\r\n        43,\r\n        36,\r\n        29,\r\n        22,\r\n        15,\r\n        23,\r\n        30,\r\n        37,\r\n        44,\r\n        51,\r\n        58,\r\n        59,\r\n        52,\r\n        45,\r\n        38,\r\n        31,\r\n        39,\r\n        46,\r\n        53,\r\n        60,\r\n        61,\r\n        54,\r\n        47,\r\n        55,\r\n        62,\r\n        63\r\n    ]);\r\n    var dctCos1 = 4017;\r\n    var dctSin1 = 799;\r\n    var dctCos3 = 3406;\r\n    var dctSin3 = 2276;\r\n    var dctCos6 = 1567;\r\n    var dctSin6 = 3784;\r\n    var dctSqrt2 = 5793;\r\n    var dctSqrt1d2 = 2896;\r\n    function JpegImage({decodeTransform = null, colorTransform = -1} = {}) {\r\n        this._decodeTransform = decodeTransform;\r\n        this._colorTransform = colorTransform;\r\n    }\r\n    function buildHuffmanTable(codeLengths, values) {\r\n        var k = 0, code = [], i, j, length = 16;\r\n        while (length > 0 && !codeLengths[length - 1]) {\r\n            length--;\r\n        }\r\n        code.push({\r\n            children: [],\r\n            index: 0\r\n        });\r\n        var p = code[0], q;\r\n        for (i = 0; i < length; i++) {\r\n            for (j = 0; j < codeLengths[i]; j++) {\r\n                p = code.pop();\r\n                p.children[p.index] = values[k];\r\n                while (p.index > 0) {\r\n                    p = code.pop();\r\n                }\r\n                p.index++;\r\n                code.push(p);\r\n                while (code.length <= i) {\r\n                    code.push(q = {\r\n                        children: [],\r\n                        index: 0\r\n                    });\r\n                    p.children[p.index] = q.children;\r\n                    p = q;\r\n                }\r\n                k++;\r\n            }\r\n            if (i + 1 < length) {\r\n                code.push(q = {\r\n                    children: [],\r\n                    index: 0\r\n                });\r\n                p.children[p.index] = q.children;\r\n                p = q;\r\n            }\r\n        }\r\n        return code[0].children;\r\n    }\r\n    function getBlockBufferOffset(component, row, col) {\r\n        return 64 * ((component.blocksPerLine + 1) * row + col);\r\n    }\r\n    function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, parseDNLMarker = false) {\r\n        var mcusPerLine = frame.mcusPerLine;\r\n        var progressive = frame.progressive;\r\n        const startOffset = offset;\r\n        let bitsData = 0, bitsCount = 0;\r\n        function readBit() {\r\n            if (bitsCount > 0) {\r\n                bitsCount--;\r\n                return bitsData >> bitsCount & 1;\r\n            }\r\n            bitsData = data[offset++];\r\n            if (bitsData === 255) {\r\n                var nextByte = data[offset++];\r\n                if (nextByte) {\r\n                    if (nextByte === 220 && parseDNLMarker) {\r\n                        offset += 2;\r\n                        const scanLines = binary.readUint16(data, offset);\r\n                        offset += 2;\r\n                        if (scanLines > 0 && scanLines !== frame.scanLines) {\r\n                            throw new DNLMarkerError('Found DNL marker (0xFFDC) while parsing scan data', scanLines);\r\n                        }\r\n                    } else if (nextByte === 217) {\r\n                        if (parseDNLMarker) {\r\n                            const maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0);\r\n                            if (maybeScanLines > 0 && Math.round(frame.scanLines / maybeScanLines) >= 10) {\r\n                                throw new DNLMarkerError('Found EOI marker (0xFFD9) while parsing scan data, ' + 'possibly caused by incorrect `scanLines` parameter', maybeScanLines);\r\n                            }\r\n                        }\r\n                        throw new EOIMarkerError('Found EOI marker (0xFFD9) while parsing scan data');\r\n                    }\r\n                    throw new JpegError(`unexpected marker ${ (bitsData << 8 | nextByte).toString(16) }`);\r\n                }\r\n            }\r\n            bitsCount = 7;\r\n            return bitsData >>> 7;\r\n        }\r\n        function decodeHuffman(tree) {\r\n            var node = tree;\r\n            while (true) {\r\n                node = node[readBit()];\r\n                switch (typeof node) {\r\n                case 'number':\r\n                    return node;\r\n                case 'object':\r\n                    continue;\r\n                }\r\n                throw new JpegError('invalid huffman sequence');\r\n            }\r\n        }\r\n        function receive(length) {\r\n            var n = 0;\r\n            while (length > 0) {\r\n                n = n << 1 | readBit();\r\n                length--;\r\n            }\r\n            return n;\r\n        }\r\n        function receiveAndExtend(length) {\r\n            if (length === 1) {\r\n                return readBit() === 1 ? 1 : -1;\r\n            }\r\n            var n = receive(length);\r\n            if (n >= 1 << length - 1) {\r\n                return n;\r\n            }\r\n            return n + (-1 << length) + 1;\r\n        }\r\n        function decodeBaseline(component, blockOffset) {\r\n            var t = decodeHuffman(component.huffmanTableDC);\r\n            var diff = t === 0 ? 0 : receiveAndExtend(t);\r\n            component.blockData[blockOffset] = component.pred += diff;\r\n            var k = 1;\r\n            while (k < 64) {\r\n                var rs = decodeHuffman(component.huffmanTableAC);\r\n                var s = rs & 15, r = rs >> 4;\r\n                if (s === 0) {\r\n                    if (r < 15) {\r\n                        break;\r\n                    }\r\n                    k += 16;\r\n                    continue;\r\n                }\r\n                k += r;\r\n                var z = dctZigZag[k];\r\n                component.blockData[blockOffset + z] = receiveAndExtend(s);\r\n                k++;\r\n            }\r\n        }\r\n        function decodeDCFirst(component, blockOffset) {\r\n            var t = decodeHuffman(component.huffmanTableDC);\r\n            var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;\r\n            component.blockData[blockOffset] = component.pred += diff;\r\n        }\r\n        function decodeDCSuccessive(component, blockOffset) {\r\n            component.blockData[blockOffset] |= readBit() << successive;\r\n        }\r\n        var eobrun = 0;\r\n        function decodeACFirst(component, blockOffset) {\r\n            if (eobrun > 0) {\r\n                eobrun--;\r\n                return;\r\n            }\r\n            var k = spectralStart, e = spectralEnd;\r\n            while (k <= e) {\r\n                var rs = decodeHuffman(component.huffmanTableAC);\r\n                var s = rs & 15, r = rs >> 4;\r\n                if (s === 0) {\r\n                    if (r < 15) {\r\n                        eobrun = receive(r) + (1 << r) - 1;\r\n                        break;\r\n                    }\r\n                    k += 16;\r\n                    continue;\r\n                }\r\n                k += r;\r\n                var z = dctZigZag[k];\r\n                component.blockData[blockOffset + z] = receiveAndExtend(s) * (1 << successive);\r\n                k++;\r\n            }\r\n        }\r\n        var successiveACState = 0, successiveACNextValue;\r\n        function decodeACSuccessive(component, blockOffset) {\r\n            var k = spectralStart;\r\n            var e = spectralEnd;\r\n            var r = 0;\r\n            var s;\r\n            var rs;\r\n            while (k <= e) {\r\n                const offsetZ = blockOffset + dctZigZag[k];\r\n                const sign = component.blockData[offsetZ] < 0 ? -1 : 1;\r\n                switch (successiveACState) {\r\n                case 0:\r\n                    rs = decodeHuffman(component.huffmanTableAC);\r\n                    s = rs & 15;\r\n                    r = rs >> 4;\r\n                    if (s === 0) {\r\n                        if (r < 15) {\r\n                            eobrun = receive(r) + (1 << r);\r\n                            successiveACState = 4;\r\n                        } else {\r\n                            r = 16;\r\n                            successiveACState = 1;\r\n                        }\r\n                    } else {\r\n                        if (s !== 1) {\r\n                            throw new JpegError('invalid ACn encoding');\r\n                        }\r\n                        successiveACNextValue = receiveAndExtend(s);\r\n                        successiveACState = r ? 2 : 3;\r\n                    }\r\n                    continue;\r\n                case 1:\r\n                case 2:\r\n                    if (component.blockData[offsetZ]) {\r\n                        component.blockData[offsetZ] += sign * (readBit() << successive);\r\n                    } else {\r\n                        r--;\r\n                        if (r === 0) {\r\n                            successiveACState = successiveACState === 2 ? 3 : 0;\r\n                        }\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    if (component.blockData[offsetZ]) {\r\n                        component.blockData[offsetZ] += sign * (readBit() << successive);\r\n                    } else {\r\n                        component.blockData[offsetZ] = successiveACNextValue << successive;\r\n                        successiveACState = 0;\r\n                    }\r\n                    break;\r\n                case 4:\r\n                    if (component.blockData[offsetZ]) {\r\n                        component.blockData[offsetZ] += sign * (readBit() << successive);\r\n                    }\r\n                    break;\r\n                }\r\n                k++;\r\n            }\r\n            if (successiveACState === 4) {\r\n                eobrun--;\r\n                if (eobrun === 0) {\r\n                    successiveACState = 0;\r\n                }\r\n            }\r\n        }\r\n        let blockRow = 0;\r\n        function decodeMcu(component, decode, mcu, row, col) {\r\n            var mcuRow = mcu / mcusPerLine | 0;\r\n            var mcuCol = mcu % mcusPerLine;\r\n            blockRow = mcuRow * component.v + row;\r\n            var blockCol = mcuCol * component.h + col;\r\n            const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);\r\n            decode(component, blockOffset);\r\n        }\r\n        function decodeBlock(component, decode, mcu) {\r\n            blockRow = mcu / component.blocksPerLine | 0;\r\n            var blockCol = mcu % component.blocksPerLine;\r\n            const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);\r\n            decode(component, blockOffset);\r\n        }\r\n        var componentsLength = components.length;\r\n        var component, i, j, k, n;\r\n        var decodeFn;\r\n        if (progressive) {\r\n            if (spectralStart === 0) {\r\n                decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\r\n            } else {\r\n                decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\r\n            }\r\n        } else {\r\n            decodeFn = decodeBaseline;\r\n        }\r\n        var mcu = 0, fileMarker;\r\n        var mcuExpected;\r\n        if (componentsLength === 1) {\r\n            mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\r\n        } else {\r\n            mcuExpected = mcusPerLine * frame.mcusPerColumn;\r\n        }\r\n        var h, v;\r\n        while (mcu <= mcuExpected) {\r\n            var mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;\r\n            if (mcuToRead > 0) {\r\n                for (i = 0; i < componentsLength; i++) {\r\n                    components[i].pred = 0;\r\n                }\r\n                eobrun = 0;\r\n                if (componentsLength === 1) {\r\n                    component = components[0];\r\n                    for (n = 0; n < mcuToRead; n++) {\r\n                        decodeBlock(component, decodeFn, mcu);\r\n                        mcu++;\r\n                    }\r\n                } else {\r\n                    for (n = 0; n < mcuToRead; n++) {\r\n                        for (i = 0; i < componentsLength; i++) {\r\n                            component = components[i];\r\n                            h = component.h;\r\n                            v = component.v;\r\n                            for (j = 0; j < v; j++) {\r\n                                for (k = 0; k < h; k++) {\r\n                                    decodeMcu(component, decodeFn, mcu, j, k);\r\n                                }\r\n                            }\r\n                        }\r\n                        mcu++;\r\n                    }\r\n                }\r\n            }\r\n            bitsCount = 0;\r\n            fileMarker = findNextFileMarker(data, offset);\r\n            if (!fileMarker) {\r\n                break;\r\n            }\r\n            if (fileMarker.invalid) {\r\n                const partialMsg = mcuToRead > 0 ? 'unexpected' : 'excessive';\r\n                sutil.warn(`decodeScan - ${ partialMsg } MCU data, current marker is: ${ fileMarker.invalid }`);\r\n                offset = fileMarker.offset;\r\n            }\r\n            if (fileMarker.marker >= 65488 && fileMarker.marker <= 65495) {\r\n                offset += 2;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return offset - startOffset;\r\n    }\r\n    function quantizeAndInverse(component, blockBufferOffset, p) {\r\n        var qt = component.quantizationTable, blockData = component.blockData;\r\n        var v0, v1, v2, v3, v4, v5, v6, v7;\r\n        var p0, p1, p2, p3, p4, p5, p6, p7;\r\n        var t;\r\n        if (!qt) {\r\n            throw new JpegError('missing required Quantization Table.');\r\n        }\r\n        for (var row = 0; row < 64; row += 8) {\r\n            p0 = blockData[blockBufferOffset + row];\r\n            p1 = blockData[blockBufferOffset + row + 1];\r\n            p2 = blockData[blockBufferOffset + row + 2];\r\n            p3 = blockData[blockBufferOffset + row + 3];\r\n            p4 = blockData[blockBufferOffset + row + 4];\r\n            p5 = blockData[blockBufferOffset + row + 5];\r\n            p6 = blockData[blockBufferOffset + row + 6];\r\n            p7 = blockData[blockBufferOffset + row + 7];\r\n            p0 *= qt[row];\r\n            if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {\r\n                t = dctSqrt2 * p0 + 512 >> 10;\r\n                p[row] = t;\r\n                p[row + 1] = t;\r\n                p[row + 2] = t;\r\n                p[row + 3] = t;\r\n                p[row + 4] = t;\r\n                p[row + 5] = t;\r\n                p[row + 6] = t;\r\n                p[row + 7] = t;\r\n                continue;\r\n            }\r\n            p1 *= qt[row + 1];\r\n            p2 *= qt[row + 2];\r\n            p3 *= qt[row + 3];\r\n            p4 *= qt[row + 4];\r\n            p5 *= qt[row + 5];\r\n            p6 *= qt[row + 6];\r\n            p7 *= qt[row + 7];\r\n            v0 = dctSqrt2 * p0 + 128 >> 8;\r\n            v1 = dctSqrt2 * p4 + 128 >> 8;\r\n            v2 = p2;\r\n            v3 = p6;\r\n            v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;\r\n            v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;\r\n            v5 = p3 << 4;\r\n            v6 = p5 << 4;\r\n            v0 = v0 + v1 + 1 >> 1;\r\n            v1 = v0 - v1;\r\n            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;\r\n            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;\r\n            v3 = t;\r\n            v4 = v4 + v6 + 1 >> 1;\r\n            v6 = v4 - v6;\r\n            v7 = v7 + v5 + 1 >> 1;\r\n            v5 = v7 - v5;\r\n            v0 = v0 + v3 + 1 >> 1;\r\n            v3 = v0 - v3;\r\n            v1 = v1 + v2 + 1 >> 1;\r\n            v2 = v1 - v2;\r\n            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\r\n            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\r\n            v7 = t;\r\n            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\r\n            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\r\n            v6 = t;\r\n            p[row] = v0 + v7;\r\n            p[row + 7] = v0 - v7;\r\n            p[row + 1] = v1 + v6;\r\n            p[row + 6] = v1 - v6;\r\n            p[row + 2] = v2 + v5;\r\n            p[row + 5] = v2 - v5;\r\n            p[row + 3] = v3 + v4;\r\n            p[row + 4] = v3 - v4;\r\n        }\r\n        for (var col = 0; col < 8; ++col) {\r\n            p0 = p[col];\r\n            p1 = p[col + 8];\r\n            p2 = p[col + 16];\r\n            p3 = p[col + 24];\r\n            p4 = p[col + 32];\r\n            p5 = p[col + 40];\r\n            p6 = p[col + 48];\r\n            p7 = p[col + 56];\r\n            if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {\r\n                t = dctSqrt2 * p0 + 8192 >> 14;\r\n                if (t < -2040) {\r\n                    t = 0;\r\n                } else if (t >= 2024) {\r\n                    t = 255;\r\n                } else {\r\n                    t = t + 2056 >> 4;\r\n                }\r\n                blockData[blockBufferOffset + col] = t;\r\n                blockData[blockBufferOffset + col + 8] = t;\r\n                blockData[blockBufferOffset + col + 16] = t;\r\n                blockData[blockBufferOffset + col + 24] = t;\r\n                blockData[blockBufferOffset + col + 32] = t;\r\n                blockData[blockBufferOffset + col + 40] = t;\r\n                blockData[blockBufferOffset + col + 48] = t;\r\n                blockData[blockBufferOffset + col + 56] = t;\r\n                continue;\r\n            }\r\n            v0 = dctSqrt2 * p0 + 2048 >> 12;\r\n            v1 = dctSqrt2 * p4 + 2048 >> 12;\r\n            v2 = p2;\r\n            v3 = p6;\r\n            v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;\r\n            v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;\r\n            v5 = p3;\r\n            v6 = p5;\r\n            v0 = (v0 + v1 + 1 >> 1) + 4112;\r\n            v1 = v0 - v1;\r\n            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;\r\n            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;\r\n            v3 = t;\r\n            v4 = v4 + v6 + 1 >> 1;\r\n            v6 = v4 - v6;\r\n            v7 = v7 + v5 + 1 >> 1;\r\n            v5 = v7 - v5;\r\n            v0 = v0 + v3 + 1 >> 1;\r\n            v3 = v0 - v3;\r\n            v1 = v1 + v2 + 1 >> 1;\r\n            v2 = v1 - v2;\r\n            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\r\n            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\r\n            v7 = t;\r\n            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\r\n            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\r\n            v6 = t;\r\n            p0 = v0 + v7;\r\n            p7 = v0 - v7;\r\n            p1 = v1 + v6;\r\n            p6 = v1 - v6;\r\n            p2 = v2 + v5;\r\n            p5 = v2 - v5;\r\n            p3 = v3 + v4;\r\n            p4 = v3 - v4;\r\n            if (p0 < 16) {\r\n                p0 = 0;\r\n            } else if (p0 >= 4080) {\r\n                p0 = 255;\r\n            } else {\r\n                p0 >>= 4;\r\n            }\r\n            if (p1 < 16) {\r\n                p1 = 0;\r\n            } else if (p1 >= 4080) {\r\n                p1 = 255;\r\n            } else {\r\n                p1 >>= 4;\r\n            }\r\n            if (p2 < 16) {\r\n                p2 = 0;\r\n            } else if (p2 >= 4080) {\r\n                p2 = 255;\r\n            } else {\r\n                p2 >>= 4;\r\n            }\r\n            if (p3 < 16) {\r\n                p3 = 0;\r\n            } else if (p3 >= 4080) {\r\n                p3 = 255;\r\n            } else {\r\n                p3 >>= 4;\r\n            }\r\n            if (p4 < 16) {\r\n                p4 = 0;\r\n            } else if (p4 >= 4080) {\r\n                p4 = 255;\r\n            } else {\r\n                p4 >>= 4;\r\n            }\r\n            if (p5 < 16) {\r\n                p5 = 0;\r\n            } else if (p5 >= 4080) {\r\n                p5 = 255;\r\n            } else {\r\n                p5 >>= 4;\r\n            }\r\n            if (p6 < 16) {\r\n                p6 = 0;\r\n            } else if (p6 >= 4080) {\r\n                p6 = 255;\r\n            } else {\r\n                p6 >>= 4;\r\n            }\r\n            if (p7 < 16) {\r\n                p7 = 0;\r\n            } else if (p7 >= 4080) {\r\n                p7 = 255;\r\n            } else {\r\n                p7 >>= 4;\r\n            }\r\n            blockData[blockBufferOffset + col] = p0;\r\n            blockData[blockBufferOffset + col + 8] = p1;\r\n            blockData[blockBufferOffset + col + 16] = p2;\r\n            blockData[blockBufferOffset + col + 24] = p3;\r\n            blockData[blockBufferOffset + col + 32] = p4;\r\n            blockData[blockBufferOffset + col + 40] = p5;\r\n            blockData[blockBufferOffset + col + 48] = p6;\r\n            blockData[blockBufferOffset + col + 56] = p7;\r\n        }\r\n    }\r\n    function buildComponentData(frame, component) {\r\n        var blocksPerLine = component.blocksPerLine;\r\n        var blocksPerColumn = component.blocksPerColumn;\r\n        var computationBuffer = new Int16Array(64);\r\n        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\r\n            for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\r\n                var offset = getBlockBufferOffset(component, blockRow, blockCol);\r\n                quantizeAndInverse(component, offset, computationBuffer);\r\n            }\r\n        }\r\n        return component.blockData;\r\n    }\r\n    function findNextFileMarker(data, currentPos, startPos = currentPos) {\r\n        const maxPos = data.length - 1;\r\n        var newPos = startPos < currentPos ? startPos : currentPos;\r\n        if (currentPos >= maxPos) {\r\n            return null;\r\n        }\r\n        var currentMarker = binary.readUint16(data, currentPos);\r\n        if (currentMarker >= 65472 && currentMarker <= 65534) {\r\n            return {\r\n                invalid: null,\r\n                marker: currentMarker,\r\n                offset: currentPos\r\n            };\r\n        }\r\n        var newMarker = binary.readUint16(data, newPos);\r\n        while (!(newMarker >= 65472 && newMarker <= 65534)) {\r\n            if (++newPos >= maxPos) {\r\n                return null;\r\n            }\r\n            newMarker = binary.readUint16(data, newPos);\r\n        }\r\n        return {\r\n            invalid: currentMarker.toString(16),\r\n            marker: newMarker,\r\n            offset: newPos\r\n        };\r\n    }\r\n    JpegImage.prototype = {\r\n        parse(data, {\r\n            dnlScanLines = null\r\n        } = {}) {\r\n            function readDataBlock() {\r\n                const length = binary.readUint16(data, offset);\r\n                offset += 2;\r\n                let endOffset = offset + length - 2;\r\n                var fileMarker = findNextFileMarker(data, endOffset, offset);\r\n                if (fileMarker && fileMarker.invalid) {\r\n                    sutil.warn('readDataBlock - incorrect length, current marker is: ' + fileMarker.invalid);\r\n                    endOffset = fileMarker.offset;\r\n                }\r\n                var array = data.subarray(offset, endOffset);\r\n                offset += array.length;\r\n                return array;\r\n            }\r\n            function prepareComponents(frame) {\r\n                var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);\r\n                var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);\r\n                for (var i = 0; i < frame.components.length; i++) {\r\n                    component = frame.components[i];\r\n                    var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);\r\n                    var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);\r\n                    var blocksPerLineForMcu = mcusPerLine * component.h;\r\n                    var blocksPerColumnForMcu = mcusPerColumn * component.v;\r\n                    var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);\r\n                    component.blockData = new Int16Array(blocksBufferSize);\r\n                    component.blocksPerLine = blocksPerLine;\r\n                    component.blocksPerColumn = blocksPerColumn;\r\n                }\r\n                frame.mcusPerLine = mcusPerLine;\r\n                frame.mcusPerColumn = mcusPerColumn;\r\n            }\r\n            var offset = 0;\r\n            var jfif = null;\r\n            var adobe = null;\r\n            var frame, resetInterval;\r\n            let numSOSMarkers = 0;\r\n            var quantizationTables = [];\r\n            var huffmanTablesAC = [], huffmanTablesDC = [];\r\n            let fileMarker = binary.readUint16(data, offset);\r\n            offset += 2;\r\n            if (fileMarker !== 65496) {\r\n                throw new JpegError('SOI not found');\r\n            }\r\n            fileMarker = binary.readUint16(data, offset);\r\n            offset += 2;\r\n            markerLoop:\r\n                while (fileMarker !== 65497) {\r\n                    var i, j, l;\r\n                    switch (fileMarker) {\r\n                    case 65504:\r\n                    case 65505:\r\n                    case 65506:\r\n                    case 65507:\r\n                    case 65508:\r\n                    case 65509:\r\n                    case 65510:\r\n                    case 65511:\r\n                    case 65512:\r\n                    case 65513:\r\n                    case 65514:\r\n                    case 65515:\r\n                    case 65516:\r\n                    case 65517:\r\n                    case 65518:\r\n                    case 65519:\r\n                    case 65534:\r\n                        var appData = readDataBlock();\r\n                        if (fileMarker === 65504) {\r\n                            if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {\r\n                                jfif = {\r\n                                    version: {\r\n                                        major: appData[5],\r\n                                        minor: appData[6]\r\n                                    },\r\n                                    densityUnits: appData[7],\r\n                                    xDensity: appData[8] << 8 | appData[9],\r\n                                    yDensity: appData[10] << 8 | appData[11],\r\n                                    thumbWidth: appData[12],\r\n                                    thumbHeight: appData[13],\r\n                                    thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\r\n                                };\r\n                            }\r\n                        }\r\n                        if (fileMarker === 65518) {\r\n                            if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101) {\r\n                                adobe = {\r\n                                    version: appData[5] << 8 | appData[6],\r\n                                    flags0: appData[7] << 8 | appData[8],\r\n                                    flags1: appData[9] << 8 | appData[10],\r\n                                    transformCode: appData[11]\r\n                                };\r\n                            }\r\n                        }\r\n                        break;\r\n                    case 65499:\r\n                        const quantizationTablesLength = binary.readUint16(data, offset);\r\n                        offset += 2;\r\n                        var quantizationTablesEnd = quantizationTablesLength + offset - 2;\r\n                        var z;\r\n                        while (offset < quantizationTablesEnd) {\r\n                            var quantizationTableSpec = data[offset++];\r\n                            var tableData = new Uint16Array(64);\r\n                            if (quantizationTableSpec >> 4 === 0) {\r\n                                for (j = 0; j < 64; j++) {\r\n                                    z = dctZigZag[j];\r\n                                    tableData[z] = data[offset++];\r\n                                }\r\n                            } else if (quantizationTableSpec >> 4 === 1) {\r\n                                for (j = 0; j < 64; j++) {\r\n                                    z = dctZigZag[j];\r\n                                    tableData[z] = binary.readUint16(data, offset);\r\n                                    offset += 2;\r\n                                }\r\n                            } else {\r\n                                throw new JpegError('DQT - invalid table spec');\r\n                            }\r\n                            quantizationTables[quantizationTableSpec & 15] = tableData;\r\n                        }\r\n                        break;\r\n                    case 65472:\r\n                    case 65473:\r\n                    case 65474:\r\n                        if (frame) {\r\n                            throw new JpegError('Only single frame JPEGs supported');\r\n                        }\r\n                        offset += 2;\r\n                        frame = {};\r\n                        frame.extended = fileMarker === 65473;\r\n                        frame.progressive = fileMarker === 65474;\r\n                        frame.precision = data[offset++];\r\n                        const sofScanLines = binary.readUint16(data, offset);\r\n                        offset += 2;\r\n                        frame.scanLines = dnlScanLines || sofScanLines;\r\n                        frame.samplesPerLine = binary.readUint16(data, offset);\r\n                        offset += 2;\r\n                        frame.components = [];\r\n                        frame.componentIds = {};\r\n                        var componentsCount = data[offset++], componentId;\r\n                        var maxH = 0, maxV = 0;\r\n                        for (i = 0; i < componentsCount; i++) {\r\n                            componentId = data[offset];\r\n                            var h = data[offset + 1] >> 4;\r\n                            var v = data[offset + 1] & 15;\r\n                            if (maxH < h) {\r\n                                maxH = h;\r\n                            }\r\n                            if (maxV < v) {\r\n                                maxV = v;\r\n                            }\r\n                            var qId = data[offset + 2];\r\n                            l = frame.components.push({\r\n                                h,\r\n                                v,\r\n                                quantizationId: qId,\r\n                                quantizationTable: null\r\n                            });\r\n                            frame.componentIds[componentId] = l - 1;\r\n                            offset += 3;\r\n                        }\r\n                        frame.maxH = maxH;\r\n                        frame.maxV = maxV;\r\n                        prepareComponents(frame);\r\n                        break;\r\n                    case 65476:\r\n                        const huffmanLength = binary.readUint16(data, offset);\r\n                        offset += 2;\r\n                        for (i = 2; i < huffmanLength;) {\r\n                            var huffmanTableSpec = data[offset++];\r\n                            var codeLengths = new Uint8Array(16);\r\n                            var codeLengthSum = 0;\r\n                            for (j = 0; j < 16; j++, offset++) {\r\n                                codeLengthSum += codeLengths[j] = data[offset];\r\n                            }\r\n                            var huffmanValues = new Uint8Array(codeLengthSum);\r\n                            for (j = 0; j < codeLengthSum; j++, offset++) {\r\n                                huffmanValues[j] = data[offset];\r\n                            }\r\n                            i += 17 + codeLengthSum;\r\n                            (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\r\n                        }\r\n                        break;\r\n                    case 65501:\r\n                        offset += 2;\r\n                        resetInterval = binary.readUint16(data, offset);\r\n                        offset += 2;\r\n                        break;\r\n                    case 65498:\r\n                        const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;\r\n                        offset += 2;\r\n                        var selectorsCount = data[offset++];\r\n                        var components = [], component;\r\n                        for (i = 0; i < selectorsCount; i++) {\r\n                            const index = data[offset++];\r\n                            var componentIndex = frame.componentIds[index];\r\n                            component = frame.components[componentIndex];\r\n                            component.index = index;\r\n                            var tableSpec = data[offset++];\r\n                            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\r\n                            component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\r\n                            components.push(component);\r\n                        }\r\n                        var spectralStart = data[offset++];\r\n                        var spectralEnd = data[offset++];\r\n                        var successiveApproximation = data[offset++];\r\n                        try {\r\n                            var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);\r\n                            offset += processed;\r\n                        } catch (ex) {\r\n                            if (ex instanceof DNLMarkerError) {\r\n                                sutil.warn(`${ ex.message } -- attempting to re-parse the JPEG image.`);\r\n                                return this.parse(data, { dnlScanLines: ex.scanLines });\r\n                            } else if (ex instanceof EOIMarkerError) {\r\n                                sutil.warn(`${ ex.message } -- ignoring the rest of the image data.`);\r\n                                break markerLoop;\r\n                            }\r\n                            throw ex;\r\n                        }\r\n                        break;\r\n                    case 65500:\r\n                        offset += 4;\r\n                        break;\r\n                    case 65535:\r\n                        if (data[offset] !== 255) {\r\n                            offset--;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        const nextFileMarker = findNextFileMarker(data, offset - 2, offset - 3);\r\n                        if (nextFileMarker && nextFileMarker.invalid) {\r\n                            sutil.warn('JpegImage.parse - unexpected data, current marker is: ' + nextFileMarker.invalid);\r\n                            offset = nextFileMarker.offset;\r\n                            break;\r\n                        }\r\n                        if (!nextFileMarker || offset >= data.length - 1) {\r\n                            sutil.warn('JpegImage.parse - reached the end of the image data ' + 'without finding an EOI marker (0xFFD9).');\r\n                            break markerLoop;\r\n                        }\r\n                        throw new JpegError('JpegImage.parse - unknown marker: ' + fileMarker.toString(16));\r\n                    }\r\n                    fileMarker = binary.readUint16(data, offset);\r\n                    offset += 2;\r\n                }\r\n            this.width = frame.samplesPerLine;\r\n            this.height = frame.scanLines;\r\n            this.jfif = jfif;\r\n            this.adobe = adobe;\r\n            this.components = [];\r\n            for (i = 0; i < frame.components.length; i++) {\r\n                component = frame.components[i];\r\n                var quantizationTable = quantizationTables[component.quantizationId];\r\n                if (quantizationTable) {\r\n                    component.quantizationTable = quantizationTable;\r\n                }\r\n                this.components.push({\r\n                    index: component.index,\r\n                    output: buildComponentData(frame, component),\r\n                    scaleX: component.h / frame.maxH,\r\n                    scaleY: component.v / frame.maxV,\r\n                    blocksPerLine: component.blocksPerLine,\r\n                    blocksPerColumn: component.blocksPerColumn\r\n                });\r\n            }\r\n            this.numComponents = this.components.length;\r\n            return undefined;\r\n        },\r\n        _getLinearizedBlockData(width, height, isSourcePDF = false) {\r\n            var scaleX = this.width / width, scaleY = this.height / height;\r\n            var component, componentScaleX, componentScaleY, blocksPerScanline;\r\n            var x, y, i, j, k;\r\n            var index;\r\n            var offset = 0;\r\n            var output;\r\n            var numComponents = this.components.length;\r\n            var dataLength = width * height * numComponents;\r\n            var data = new Uint8ClampedArray(dataLength);\r\n            var xScaleBlockOffset = new Uint32Array(width);\r\n            var mask3LSB = 4294967288;\r\n            let lastComponentScaleX;\r\n            for (i = 0; i < numComponents; i++) {\r\n                component = this.components[i];\r\n                componentScaleX = component.scaleX * scaleX;\r\n                componentScaleY = component.scaleY * scaleY;\r\n                offset = i;\r\n                output = component.output;\r\n                blocksPerScanline = component.blocksPerLine + 1 << 3;\r\n                if (componentScaleX !== lastComponentScaleX) {\r\n                    for (x = 0; x < width; x++) {\r\n                        j = 0 | x * componentScaleX;\r\n                        xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;\r\n                    }\r\n                    lastComponentScaleX = componentScaleX;\r\n                }\r\n                for (y = 0; y < height; y++) {\r\n                    j = 0 | y * componentScaleY;\r\n                    index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;\r\n                    for (x = 0; x < width; x++) {\r\n                        data[offset] = output[index + xScaleBlockOffset[x]];\r\n                        offset += numComponents;\r\n                    }\r\n                }\r\n            }\r\n            let transform = this._decodeTransform;\r\n            if (!isSourcePDF && numComponents === 4 && !transform) {\r\n                transform = new Int32Array([\r\n                    -256,\r\n                    255,\r\n                    -256,\r\n                    255,\r\n                    -256,\r\n                    255,\r\n                    -256,\r\n                    255\r\n                ]);\r\n            }\r\n            if (transform) {\r\n                for (i = 0; i < dataLength;) {\r\n                    for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {\r\n                        data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];\r\n                    }\r\n                }\r\n            }\r\n            return data;\r\n        },\r\n        get _isColorConversionNeeded() {\r\n            if (this.adobe) {\r\n                return !!this.adobe.transformCode;\r\n            }\r\n            if (this.numComponents === 3) {\r\n                if (this._colorTransform === 0) {\r\n                    return false;\r\n                } else if (this.components[0].index === 82 && this.components[1].index === 71 && this.components[2].index === 66) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n            if (this._colorTransform === 1) {\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n        _convertYccToRgb: function convertYccToRgb(data) {\r\n            var Y, Cb, Cr;\r\n            for (var i = 0, length = data.length; i < length; i += 3) {\r\n                Y = data[i];\r\n                Cb = data[i + 1];\r\n                Cr = data[i + 2];\r\n                data[i] = Y - 179.456 + 1.402 * Cr;\r\n                data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;\r\n                data[i + 2] = Y - 226.816 + 1.772 * Cb;\r\n            }\r\n            return data;\r\n        },\r\n        _convertYcckToRgb: function convertYcckToRgb(data) {\r\n            var Y, Cb, Cr, k;\r\n            var offset = 0;\r\n            for (var i = 0, length = data.length; i < length; i += 4) {\r\n                Y = data[i];\r\n                Cb = data[i + 1];\r\n                Cr = data[i + 2];\r\n                k = data[i + 3];\r\n                data[offset++] = -122.67195406894 + Cb * (-0.0000660635669420364 * Cb + 0.000437130475926232 * Cr - 0.000054080610064599 * Y + 0.00048449797120281 * k - 0.154362151871126) + Cr * (-0.000957964378445773 * Cr + 0.000817076911346625 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (0.000961250184130688 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-0.000336197177618394 * k + 0.484791561490776);\r\n                data[offset++] = 107.268039397724 + Cb * (0.0000219927104525741 * Cb - 0.000640992018297945 * Cr + 0.000659397001245577 * Y + 0.000426105652938837 * k - 0.176491792462875) + Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y + 0.000770482631801132 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-0.000318913117588328 * k - 0.213742400323665);\r\n                data[offset++] = -20.810012546947 + Cb * (-0.000570115196973677 * Cb - 0.0000263409051004589 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-0.0000153496057440975 * Cr - 0.000132689043961446 * Y + 0.000560833691242812 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-0.000343531996510555 * k + 0.24165260232407);\r\n            }\r\n            return data.subarray(0, offset);\r\n        },\r\n        _convertYcckToCmyk: function convertYcckToCmyk(data) {\r\n            var Y, Cb, Cr;\r\n            for (var i = 0, length = data.length; i < length; i += 4) {\r\n                Y = data[i];\r\n                Cb = data[i + 1];\r\n                Cr = data[i + 2];\r\n                data[i] = 434.456 - Y - 1.402 * Cr;\r\n                data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;\r\n                data[i + 2] = 481.816 - Y - 1.772 * Cb;\r\n            }\r\n            return data;\r\n        },\r\n        _convertCmykToRgb: function convertCmykToRgb(data) {\r\n            var c, m, y, k;\r\n            var offset = 0;\r\n            for (var i = 0, length = data.length; i < length; i += 4) {\r\n                c = data[i];\r\n                m = data[i + 1];\r\n                y = data[i + 2];\r\n                k = data[i + 3];\r\n                data[offset++] = 255 + c * (-0.00006747147073602441 * c + 0.0008379262121013727 * m + 0.0002894718188643294 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (0.000026374107616089405 * m - 0.00008626949158638572 * y - 0.0002748769067499491 * k - 0.02155688794978967) + y * (-0.00003878099212869363 * y - 0.0003267808279485286 * k + 0.0686742238595345) - k * (0.0003361971776183937 * k + 0.7430659151342254);\r\n                data[offset++] = 255 + c * (0.00013596372813588848 * c + 0.000924537132573585 * m + 0.00010567359618683593 * y + 0.0004791864687436512 * k - 0.3109689587515875) + m * (-0.00023545346108370344 * m + 0.0002702845253534714 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (0.00006834815998235662 * y + 0.00015168452363460973 * k - 0.09751927774728933) - k * (0.0003189131175883281 * k + 0.7364883807733168);\r\n                data[offset++] = 255 + c * (0.000013598650411385307 * c + 0.00012423956175490851 * m + 0.0004751985097583589 * y - 0.0000036729317476630422 * k - 0.05562186980264034) + m * (0.00016141380598724676 * m + 0.0009692239130725186 * y + 0.0007782692450036253 * k - 0.44015232367526463) + y * (5.068882914068769e-7 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (0.0003435319965105553 * k + 0.7063770186160144);\r\n            }\r\n            return data.subarray(0, offset);\r\n        },\r\n        getData({width, height, forceRGB = false, isSourcePDF = false}) {\r\n            if (typeof PDFJSDev === 'undefined' || PDFJSDev.test('!PRODUCTION || TESTING')) {\r\n                sutil.assert(isSourcePDF === true, 'JpegImage.getData: Unexpected \"isSourcePDF\" value for PDF files.');\r\n            }\r\n            if (this.numComponents > 4) {\r\n                throw new JpegError('Unsupported color mode');\r\n            }\r\n            var data = this._getLinearizedBlockData(width, height, isSourcePDF);\r\n            if (this.numComponents === 1 && forceRGB) {\r\n                var dataLength = data.length;\r\n                var rgbData = new Uint8ClampedArray(dataLength * 3);\r\n                var offset = 0;\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    var grayColor = data[i];\r\n                    rgbData[offset++] = grayColor;\r\n                    rgbData[offset++] = grayColor;\r\n                    rgbData[offset++] = grayColor;\r\n                }\r\n                return rgbData;\r\n            } else if (this.numComponents === 3 && this._isColorConversionNeeded) {\r\n                return this._convertYccToRgb(data);\r\n            } else if (this.numComponents === 4) {\r\n                if (this._isColorConversionNeeded) {\r\n                    if (forceRGB) {\r\n                        return this._convertYcckToRgb(data);\r\n                    }\r\n                    return this._convertYcckToCmyk(data);\r\n                } else if (forceRGB) {\r\n                    return this._convertCmykToRgb(data);\r\n                }\r\n            }\r\n            return data;\r\n        }\r\n    };\r\n\r\n    return jpeg.JpegImage = JpegImage;\r\n\r\n});\ndefine('skylark-graphics-image/jpeg-stream',[\r\n    'skylark-langx-objects/shadow',\r\n    'skylark-io-streams/decode-stream',\r\n    \"./jpeg\",\r\n    './jpeg-image'\r\n], function (shadow,DecodeStream, jpeg,JpegImage) {\r\n    'use strict';\r\n\r\n    function JpegStream(stream, maybeLength, dict, params) {\r\n        let ch;\r\n        while ((ch = stream.getByte()) !== -1) {\r\n            if (ch === 255) {\r\n                stream.skip(-1);\r\n                break;\r\n            }\r\n        }\r\n        this.stream = stream;\r\n        this.maybeLength = maybeLength;\r\n        this.dict = dict;\r\n        this.params = params;\r\n        DecodeStream.call(this, maybeLength);\r\n    }\r\n\r\n    JpegStream.prototype = Object.create(DecodeStream.prototype);\r\n\r\n    Object.defineProperty(JpegStream.prototype, 'bytes', {\r\n        get: function JpegStream_bytes() {\r\n            return shadow(this, 'bytes', this.stream.getBytes(this.maybeLength));\r\n        },\r\n        configurable: true\r\n    });\r\n\r\n    JpegStream.prototype.ensureBuffer = function (requested) {\r\n    };\r\n\r\n    JpegStream.prototype.readBlock = function () {\r\n        if (this.eof) {\r\n            return;\r\n        }\r\n        const jpegOptions = {\r\n            decodeTransform: undefined,\r\n            colorTransform: undefined\r\n        };\r\n        const decodeArr = this.dict.getArray('Decode', 'D');\r\n        if (this.forceRGB && Array.isArray(decodeArr)) {\r\n            const bitsPerComponent = this.dict.get('BitsPerComponent') || 8;\r\n            const decodeArrLength = decodeArr.length;\r\n            const transform = new Int32Array(decodeArrLength);\r\n            let transformNeeded = false;\r\n            const maxValue = (1 << bitsPerComponent) - 1;\r\n            for (let i = 0; i < decodeArrLength; i += 2) {\r\n                transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;\r\n                transform[i + 1] = decodeArr[i] * maxValue | 0;\r\n                if (transform[i] !== 256 || transform[i + 1] !== 0) {\r\n                    transformNeeded = true;\r\n                }\r\n            }\r\n            if (transformNeeded) {\r\n                jpegOptions.decodeTransform = transform;\r\n            }\r\n        }\r\n\r\n        //modified by lwf\r\n        //ToDo \r\n        ///if (primitives.isDict(this.params)) {\r\n        if (this.params && this.params.get) {\r\n            const colorTransform = this.params.get('ColorTransform');\r\n            if (Number.isInteger(colorTransform)) {\r\n                jpegOptions.colorTransform = colorTransform;\r\n            }\r\n        }\r\n        const jpegImage = new JpegImage(jpegOptions);\r\n        jpegImage.parse(this.bytes);\r\n        const data = jpegImage.getData({\r\n            width: this.drawWidth,\r\n            height: this.drawHeight,\r\n            forceRGB: this.forceRGB,\r\n            isSourcePDF: true\r\n        });\r\n        this.buffer = data;\r\n        this.bufferLength = data.length;\r\n        this.eof = true;\r\n    };\r\n\r\n    return jpeg.JpegStream = JpegStream;\r\n\r\n});\ndefine('skylark-graphics-image/main',[\r\n\t\"./jpeg\",\r\n\t\"./jpeg-image\",\r\n\t\"./jpeg-stream\"\r\n],function(jpeg){\r\n\treturn jpeg;\r\n});\ndefine('skylark-graphics-image', ['skylark-graphics-image/main'], function (main) { return main; });\n\n"]}