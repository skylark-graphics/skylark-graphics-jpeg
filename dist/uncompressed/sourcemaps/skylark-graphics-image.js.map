{"version":3,"sources":["skylark-graphics-image.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-graphics-image.js","sourcesContent":["define('skylark-graphics-image/jpeg',[\r\n  \"skylark-langx-ns\"\r\n],function(skylark){\r\n  'use strict';\r\n\r\n  return skylark.attach(\"graphics.jpeg\");\r\n});\ndefine('skylark-graphics-image/jpeg-image',[\r\n    \"skylark-langx-exceptions/base-exception\",\r\n    'skylark-langx-binary',\r\n    \"./jpeg\"\r\n], function (BaseException, binary,jpeg) {\r\n    'use strict';\r\n    class JpegError extends BaseException {\r\n        constructor(msg) {\r\n            super(`JPEG error: ${ msg }`);\r\n        }\r\n    }\r\n    class DNLMarkerError extends BaseException {\r\n        constructor(message, scanLines) {\r\n            super(message);\r\n            this.scanLines = scanLines;\r\n        }\r\n    }\r\n    class EOIMarkerError extends BaseException {\r\n    }\r\n\r\n    var dctZigZag = new Uint8Array([\r\n        0,\r\n        1,\r\n        8,\r\n        16,\r\n        9,\r\n        2,\r\n        3,\r\n        10,\r\n        17,\r\n        24,\r\n        32,\r\n        25,\r\n        18,\r\n        11,\r\n        4,\r\n        5,\r\n        12,\r\n        19,\r\n        26,\r\n        33,\r\n        40,\r\n        48,\r\n        41,\r\n        34,\r\n        27,\r\n        20,\r\n        13,\r\n        6,\r\n        7,\r\n        14,\r\n        21,\r\n        28,\r\n        35,\r\n        42,\r\n        49,\r\n        56,\r\n        57,\r\n        50,\r\n        43,\r\n        36,\r\n        29,\r\n        22,\r\n        15,\r\n        23,\r\n        30,\r\n        37,\r\n        44,\r\n        51,\r\n        58,\r\n        59,\r\n        52,\r\n        45,\r\n        38,\r\n        31,\r\n        39,\r\n        46,\r\n        53,\r\n        60,\r\n        61,\r\n        54,\r\n        47,\r\n        55,\r\n        62,\r\n        63\r\n    ]);\r\n    var dctCos1 = 4017;\r\n    var dctSin1 = 799;\r\n    var dctCos3 = 3406;\r\n    var dctSin3 = 2276;\r\n    var dctCos6 = 1567;\r\n    var dctSin6 = 3784;\r\n    var dctSqrt2 = 5793;\r\n    var dctSqrt1d2 = 2896;\r\n    function JpegImage({decodeTransform = null, colorTransform = -1} = {}) {\r\n        this._decodeTransform = decodeTransform;\r\n        this._colorTransform = colorTransform;\r\n    }\r\n    function buildHuffmanTable(codeLengths, values) {\r\n        var k = 0, code = [], i, j, length = 16;\r\n        while (length > 0 && !codeLengths[length - 1]) {\r\n            length--;\r\n        }\r\n        code.push({\r\n            children: [],\r\n            index: 0\r\n        });\r\n        var p = code[0], q;\r\n        for (i = 0; i < length; i++) {\r\n            for (j = 0; j < codeLengths[i]; j++) {\r\n                p = code.pop();\r\n                p.children[p.index] = values[k];\r\n                while (p.index > 0) {\r\n                    p = code.pop();\r\n                }\r\n                p.index++;\r\n                code.push(p);\r\n                while (code.length <= i) {\r\n                    code.push(q = {\r\n                        children: [],\r\n                        index: 0\r\n                    });\r\n                    p.children[p.index] = q.children;\r\n                    p = q;\r\n                }\r\n                k++;\r\n            }\r\n            if (i + 1 < length) {\r\n                code.push(q = {\r\n                    children: [],\r\n                    index: 0\r\n                });\r\n                p.children[p.index] = q.children;\r\n                p = q;\r\n            }\r\n        }\r\n        return code[0].children;\r\n    }\r\n    function getBlockBufferOffset(component, row, col) {\r\n        return 64 * ((component.blocksPerLine + 1) * row + col);\r\n    }\r\n    function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, parseDNLMarker = false) {\r\n        var mcusPerLine = frame.mcusPerLine;\r\n        var progressive = frame.progressive;\r\n        const startOffset = offset;\r\n        let bitsData = 0, bitsCount = 0;\r\n        function readBit() {\r\n            if (bitsCount > 0) {\r\n                bitsCount--;\r\n                return bitsData >> bitsCount & 1;\r\n            }\r\n            bitsData = data[offset++];\r\n            if (bitsData === 255) {\r\n                var nextByte = data[offset++];\r\n                if (nextByte) {\r\n                    if (nextByte === 220 && parseDNLMarker) {\r\n                        offset += 2;\r\n                        const scanLines = binary.readUint16(data, offset);\r\n                        offset += 2;\r\n                        if (scanLines > 0 && scanLines !== frame.scanLines) {\r\n                            throw new DNLMarkerError('Found DNL marker (0xFFDC) while parsing scan data', scanLines);\r\n                        }\r\n                    } else if (nextByte === 217) {\r\n                        if (parseDNLMarker) {\r\n                            const maybeScanLines = blockRow * (frame.precision === 8 ? 8 : 0);\r\n                            if (maybeScanLines > 0 && Math.round(frame.scanLines / maybeScanLines) >= 10) {\r\n                                throw new DNLMarkerError('Found EOI marker (0xFFD9) while parsing scan data, ' + 'possibly caused by incorrect `scanLines` parameter', maybeScanLines);\r\n                            }\r\n                        }\r\n                        throw new EOIMarkerError('Found EOI marker (0xFFD9) while parsing scan data');\r\n                    }\r\n                    throw new JpegError(`unexpected marker ${ (bitsData << 8 | nextByte).toString(16) }`);\r\n                }\r\n            }\r\n            bitsCount = 7;\r\n            return bitsData >>> 7;\r\n        }\r\n        function decodeHuffman(tree) {\r\n            var node = tree;\r\n            while (true) {\r\n                node = node[readBit()];\r\n                switch (typeof node) {\r\n                case 'number':\r\n                    return node;\r\n                case 'object':\r\n                    continue;\r\n                }\r\n                throw new JpegError('invalid huffman sequence');\r\n            }\r\n        }\r\n        function receive(length) {\r\n            var n = 0;\r\n            while (length > 0) {\r\n                n = n << 1 | readBit();\r\n                length--;\r\n            }\r\n            return n;\r\n        }\r\n        function receiveAndExtend(length) {\r\n            if (length === 1) {\r\n                return readBit() === 1 ? 1 : -1;\r\n            }\r\n            var n = receive(length);\r\n            if (n >= 1 << length - 1) {\r\n                return n;\r\n            }\r\n            return n + (-1 << length) + 1;\r\n        }\r\n        function decodeBaseline(component, blockOffset) {\r\n            var t = decodeHuffman(component.huffmanTableDC);\r\n            var diff = t === 0 ? 0 : receiveAndExtend(t);\r\n            component.blockData[blockOffset] = component.pred += diff;\r\n            var k = 1;\r\n            while (k < 64) {\r\n                var rs = decodeHuffman(component.huffmanTableAC);\r\n                var s = rs & 15, r = rs >> 4;\r\n                if (s === 0) {\r\n                    if (r < 15) {\r\n                        break;\r\n                    }\r\n                    k += 16;\r\n                    continue;\r\n                }\r\n                k += r;\r\n                var z = dctZigZag[k];\r\n                component.blockData[blockOffset + z] = receiveAndExtend(s);\r\n                k++;\r\n            }\r\n        }\r\n        function decodeDCFirst(component, blockOffset) {\r\n            var t = decodeHuffman(component.huffmanTableDC);\r\n            var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;\r\n            component.blockData[blockOffset] = component.pred += diff;\r\n        }\r\n        function decodeDCSuccessive(component, blockOffset) {\r\n            component.blockData[blockOffset] |= readBit() << successive;\r\n        }\r\n        var eobrun = 0;\r\n        function decodeACFirst(component, blockOffset) {\r\n            if (eobrun > 0) {\r\n                eobrun--;\r\n                return;\r\n            }\r\n            var k = spectralStart, e = spectralEnd;\r\n            while (k <= e) {\r\n                var rs = decodeHuffman(component.huffmanTableAC);\r\n                var s = rs & 15, r = rs >> 4;\r\n                if (s === 0) {\r\n                    if (r < 15) {\r\n                        eobrun = receive(r) + (1 << r) - 1;\r\n                        break;\r\n                    }\r\n                    k += 16;\r\n                    continue;\r\n                }\r\n                k += r;\r\n                var z = dctZigZag[k];\r\n                component.blockData[blockOffset + z] = receiveAndExtend(s) * (1 << successive);\r\n                k++;\r\n            }\r\n        }\r\n        var successiveACState = 0, successiveACNextValue;\r\n        function decodeACSuccessive(component, blockOffset) {\r\n            var k = spectralStart;\r\n            var e = spectralEnd;\r\n            var r = 0;\r\n            var s;\r\n            var rs;\r\n            while (k <= e) {\r\n                const offsetZ = blockOffset + dctZigZag[k];\r\n                const sign = component.blockData[offsetZ] < 0 ? -1 : 1;\r\n                switch (successiveACState) {\r\n                case 0:\r\n                    rs = decodeHuffman(component.huffmanTableAC);\r\n                    s = rs & 15;\r\n                    r = rs >> 4;\r\n                    if (s === 0) {\r\n                        if (r < 15) {\r\n                            eobrun = receive(r) + (1 << r);\r\n                            successiveACState = 4;\r\n                        } else {\r\n                            r = 16;\r\n                            successiveACState = 1;\r\n                        }\r\n                    } else {\r\n                        if (s !== 1) {\r\n                            throw new JpegError('invalid ACn encoding');\r\n                        }\r\n                        successiveACNextValue = receiveAndExtend(s);\r\n                        successiveACState = r ? 2 : 3;\r\n                    }\r\n                    continue;\r\n                case 1:\r\n                case 2:\r\n                    if (component.blockData[offsetZ]) {\r\n                        component.blockData[offsetZ] += sign * (readBit() << successive);\r\n                    } else {\r\n                        r--;\r\n                        if (r === 0) {\r\n                            successiveACState = successiveACState === 2 ? 3 : 0;\r\n                        }\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    if (component.blockData[offsetZ]) {\r\n                        component.blockData[offsetZ] += sign * (readBit() << successive);\r\n                    } else {\r\n                        component.blockData[offsetZ] = successiveACNextValue << successive;\r\n                        successiveACState = 0;\r\n                    }\r\n                    break;\r\n                case 4:\r\n                    if (component.blockData[offsetZ]) {\r\n                        component.blockData[offsetZ] += sign * (readBit() << successive);\r\n                    }\r\n                    break;\r\n                }\r\n                k++;\r\n            }\r\n            if (successiveACState === 4) {\r\n                eobrun--;\r\n                if (eobrun === 0) {\r\n                    successiveACState = 0;\r\n                }\r\n            }\r\n        }\r\n        let blockRow = 0;\r\n        function decodeMcu(component, decode, mcu, row, col) {\r\n            var mcuRow = mcu / mcusPerLine | 0;\r\n            var mcuCol = mcu % mcusPerLine;\r\n            blockRow = mcuRow * component.v + row;\r\n            var blockCol = mcuCol * component.h + col;\r\n            const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);\r\n            decode(component, blockOffset);\r\n        }\r\n        function decodeBlock(component, decode, mcu) {\r\n            blockRow = mcu / component.blocksPerLine | 0;\r\n            var blockCol = mcu % component.blocksPerLine;\r\n            const blockOffset = getBlockBufferOffset(component, blockRow, blockCol);\r\n            decode(component, blockOffset);\r\n        }\r\n        var componentsLength = components.length;\r\n        var component, i, j, k, n;\r\n        var decodeFn;\r\n        if (progressive) {\r\n            if (spectralStart === 0) {\r\n                decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\r\n            } else {\r\n                decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\r\n            }\r\n        } else {\r\n            decodeFn = decodeBaseline;\r\n        }\r\n        var mcu = 0, fileMarker;\r\n        var mcuExpected;\r\n        if (componentsLength === 1) {\r\n            mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\r\n        } else {\r\n            mcuExpected = mcusPerLine * frame.mcusPerColumn;\r\n        }\r\n        var h, v;\r\n        while (mcu <= mcuExpected) {\r\n            var mcuToRead = resetInterval ? Math.min(mcuExpected - mcu, resetInterval) : mcuExpected;\r\n            if (mcuToRead > 0) {\r\n                for (i = 0; i < componentsLength; i++) {\r\n                    components[i].pred = 0;\r\n                }\r\n                eobrun = 0;\r\n                if (componentsLength === 1) {\r\n                    component = components[0];\r\n                    for (n = 0; n < mcuToRead; n++) {\r\n                        decodeBlock(component, decodeFn, mcu);\r\n                        mcu++;\r\n                    }\r\n                } else {\r\n                    for (n = 0; n < mcuToRead; n++) {\r\n                        for (i = 0; i < componentsLength; i++) {\r\n                            component = components[i];\r\n                            h = component.h;\r\n                            v = component.v;\r\n                            for (j = 0; j < v; j++) {\r\n                                for (k = 0; k < h; k++) {\r\n                                    decodeMcu(component, decodeFn, mcu, j, k);\r\n                                }\r\n                            }\r\n                        }\r\n                        mcu++;\r\n                    }\r\n                }\r\n            }\r\n            bitsCount = 0;\r\n            fileMarker = findNextFileMarker(data, offset);\r\n            if (!fileMarker) {\r\n                break;\r\n            }\r\n            if (fileMarker.invalid) {\r\n                const partialMsg = mcuToRead > 0 ? 'unexpected' : 'excessive';\r\n                sutil.warn(`decodeScan - ${ partialMsg } MCU data, current marker is: ${ fileMarker.invalid }`);\r\n                offset = fileMarker.offset;\r\n            }\r\n            if (fileMarker.marker >= 65488 && fileMarker.marker <= 65495) {\r\n                offset += 2;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return offset - startOffset;\r\n    }\r\n    function quantizeAndInverse(component, blockBufferOffset, p) {\r\n        var qt = component.quantizationTable, blockData = component.blockData;\r\n        var v0, v1, v2, v3, v4, v5, v6, v7;\r\n        var p0, p1, p2, p3, p4, p5, p6, p7;\r\n        var t;\r\n        if (!qt) {\r\n            throw new JpegError('missing required Quantization Table.');\r\n        }\r\n        for (var row = 0; row < 64; row += 8) {\r\n            p0 = blockData[blockBufferOffset + row];\r\n            p1 = blockData[blockBufferOffset + row + 1];\r\n            p2 = blockData[blockBufferOffset + row + 2];\r\n            p3 = blockData[blockBufferOffset + row + 3];\r\n            p4 = blockData[blockBufferOffset + row + 4];\r\n            p5 = blockData[blockBufferOffset + row + 5];\r\n            p6 = blockData[blockBufferOffset + row + 6];\r\n            p7 = blockData[blockBufferOffset + row + 7];\r\n            p0 *= qt[row];\r\n            if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {\r\n                t = dctSqrt2 * p0 + 512 >> 10;\r\n                p[row] = t;\r\n                p[row + 1] = t;\r\n                p[row + 2] = t;\r\n                p[row + 3] = t;\r\n                p[row + 4] = t;\r\n                p[row + 5] = t;\r\n                p[row + 6] = t;\r\n                p[row + 7] = t;\r\n                continue;\r\n            }\r\n            p1 *= qt[row + 1];\r\n            p2 *= qt[row + 2];\r\n            p3 *= qt[row + 3];\r\n            p4 *= qt[row + 4];\r\n            p5 *= qt[row + 5];\r\n            p6 *= qt[row + 6];\r\n            p7 *= qt[row + 7];\r\n            v0 = dctSqrt2 * p0 + 128 >> 8;\r\n            v1 = dctSqrt2 * p4 + 128 >> 8;\r\n            v2 = p2;\r\n            v3 = p6;\r\n            v4 = dctSqrt1d2 * (p1 - p7) + 128 >> 8;\r\n            v7 = dctSqrt1d2 * (p1 + p7) + 128 >> 8;\r\n            v5 = p3 << 4;\r\n            v6 = p5 << 4;\r\n            v0 = v0 + v1 + 1 >> 1;\r\n            v1 = v0 - v1;\r\n            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;\r\n            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;\r\n            v3 = t;\r\n            v4 = v4 + v6 + 1 >> 1;\r\n            v6 = v4 - v6;\r\n            v7 = v7 + v5 + 1 >> 1;\r\n            v5 = v7 - v5;\r\n            v0 = v0 + v3 + 1 >> 1;\r\n            v3 = v0 - v3;\r\n            v1 = v1 + v2 + 1 >> 1;\r\n            v2 = v1 - v2;\r\n            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\r\n            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\r\n            v7 = t;\r\n            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\r\n            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\r\n            v6 = t;\r\n            p[row] = v0 + v7;\r\n            p[row + 7] = v0 - v7;\r\n            p[row + 1] = v1 + v6;\r\n            p[row + 6] = v1 - v6;\r\n            p[row + 2] = v2 + v5;\r\n            p[row + 5] = v2 - v5;\r\n            p[row + 3] = v3 + v4;\r\n            p[row + 4] = v3 - v4;\r\n        }\r\n        for (var col = 0; col < 8; ++col) {\r\n            p0 = p[col];\r\n            p1 = p[col + 8];\r\n            p2 = p[col + 16];\r\n            p3 = p[col + 24];\r\n            p4 = p[col + 32];\r\n            p5 = p[col + 40];\r\n            p6 = p[col + 48];\r\n            p7 = p[col + 56];\r\n            if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {\r\n                t = dctSqrt2 * p0 + 8192 >> 14;\r\n                if (t < -2040) {\r\n                    t = 0;\r\n                } else if (t >= 2024) {\r\n                    t = 255;\r\n                } else {\r\n                    t = t + 2056 >> 4;\r\n                }\r\n                blockData[blockBufferOffset + col] = t;\r\n                blockData[blockBufferOffset + col + 8] = t;\r\n                blockData[blockBufferOffset + col + 16] = t;\r\n                blockData[blockBufferOffset + col + 24] = t;\r\n                blockData[blockBufferOffset + col + 32] = t;\r\n                blockData[blockBufferOffset + col + 40] = t;\r\n                blockData[blockBufferOffset + col + 48] = t;\r\n                blockData[blockBufferOffset + col + 56] = t;\r\n                continue;\r\n            }\r\n            v0 = dctSqrt2 * p0 + 2048 >> 12;\r\n            v1 = dctSqrt2 * p4 + 2048 >> 12;\r\n            v2 = p2;\r\n            v3 = p6;\r\n            v4 = dctSqrt1d2 * (p1 - p7) + 2048 >> 12;\r\n            v7 = dctSqrt1d2 * (p1 + p7) + 2048 >> 12;\r\n            v5 = p3;\r\n            v6 = p5;\r\n            v0 = (v0 + v1 + 1 >> 1) + 4112;\r\n            v1 = v0 - v1;\r\n            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;\r\n            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;\r\n            v3 = t;\r\n            v4 = v4 + v6 + 1 >> 1;\r\n            v6 = v4 - v6;\r\n            v7 = v7 + v5 + 1 >> 1;\r\n            v5 = v7 - v5;\r\n            v0 = v0 + v3 + 1 >> 1;\r\n            v3 = v0 - v3;\r\n            v1 = v1 + v2 + 1 >> 1;\r\n            v2 = v1 - v2;\r\n            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\r\n            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\r\n            v7 = t;\r\n            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\r\n            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\r\n            v6 = t;\r\n            p0 = v0 + v7;\r\n            p7 = v0 - v7;\r\n            p1 = v1 + v6;\r\n            p6 = v1 - v6;\r\n            p2 = v2 + v5;\r\n            p5 = v2 - v5;\r\n            p3 = v3 + v4;\r\n            p4 = v3 - v4;\r\n            if (p0 < 16) {\r\n                p0 = 0;\r\n            } else if (p0 >= 4080) {\r\n                p0 = 255;\r\n            } else {\r\n                p0 >>= 4;\r\n            }\r\n            if (p1 < 16) {\r\n                p1 = 0;\r\n            } else if (p1 >= 4080) {\r\n                p1 = 255;\r\n            } else {\r\n                p1 >>= 4;\r\n            }\r\n            if (p2 < 16) {\r\n                p2 = 0;\r\n            } else if (p2 >= 4080) {\r\n                p2 = 255;\r\n            } else {\r\n                p2 >>= 4;\r\n            }\r\n            if (p3 < 16) {\r\n                p3 = 0;\r\n            } else if (p3 >= 4080) {\r\n                p3 = 255;\r\n            } else {\r\n                p3 >>= 4;\r\n            }\r\n            if (p4 < 16) {\r\n                p4 = 0;\r\n            } else if (p4 >= 4080) {\r\n                p4 = 255;\r\n            } else {\r\n                p4 >>= 4;\r\n            }\r\n            if (p5 < 16) {\r\n                p5 = 0;\r\n            } else if (p5 >= 4080) {\r\n                p5 = 255;\r\n            } else {\r\n                p5 >>= 4;\r\n            }\r\n            if (p6 < 16) {\r\n                p6 = 0;\r\n            } else if (p6 >= 4080) {\r\n                p6 = 255;\r\n            } else {\r\n                p6 >>= 4;\r\n            }\r\n            if (p7 < 16) {\r\n                p7 = 0;\r\n            } else if (p7 >= 4080) {\r\n                p7 = 255;\r\n            } else {\r\n                p7 >>= 4;\r\n            }\r\n            blockData[blockBufferOffset + col] = p0;\r\n            blockData[blockBufferOffset + col + 8] = p1;\r\n            blockData[blockBufferOffset + col + 16] = p2;\r\n            blockData[blockBufferOffset + col + 24] = p3;\r\n            blockData[blockBufferOffset + col + 32] = p4;\r\n            blockData[blockBufferOffset + col + 40] = p5;\r\n            blockData[blockBufferOffset + col + 48] = p6;\r\n            blockData[blockBufferOffset + col + 56] = p7;\r\n        }\r\n    }\r\n    function buildComponentData(frame, component) {\r\n        var blocksPerLine = component.blocksPerLine;\r\n        var blocksPerColumn = component.blocksPerColumn;\r\n        var computationBuffer = new Int16Array(64);\r\n        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\r\n            for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\r\n                var offset = getBlockBufferOffset(component, blockRow, blockCol);\r\n                quantizeAndInverse(component, offset, computationBuffer);\r\n            }\r\n        }\r\n        return component.blockData;\r\n    }\r\n    function findNextFileMarker(data, currentPos, startPos = currentPos) {\r\n        const maxPos = data.length - 1;\r\n        var newPos = startPos < currentPos ? startPos : currentPos;\r\n        if (currentPos >= maxPos) {\r\n            return null;\r\n        }\r\n        var currentMarker = binary.readUint16(data, currentPos);\r\n        if (currentMarker >= 65472 && currentMarker <= 65534) {\r\n            return {\r\n                invalid: null,\r\n                marker: currentMarker,\r\n                offset: currentPos\r\n            };\r\n        }\r\n        var newMarker = binary.readUint16(data, newPos);\r\n        while (!(newMarker >= 65472 && newMarker <= 65534)) {\r\n            if (++newPos >= maxPos) {\r\n                return null;\r\n            }\r\n            newMarker = binary.readUint16(data, newPos);\r\n        }\r\n        return {\r\n            invalid: currentMarker.toString(16),\r\n            marker: newMarker,\r\n            offset: newPos\r\n        };\r\n    }\r\n    JpegImage.prototype = {\r\n        parse(data, {\r\n            dnlScanLines = null\r\n        } = {}) {\r\n            function readDataBlock() {\r\n                const length = binary.readUint16(data, offset);\r\n                offset += 2;\r\n                let endOffset = offset + length - 2;\r\n                var fileMarker = findNextFileMarker(data, endOffset, offset);\r\n                if (fileMarker && fileMarker.invalid) {\r\n                    sutil.warn('readDataBlock - incorrect length, current marker is: ' + fileMarker.invalid);\r\n                    endOffset = fileMarker.offset;\r\n                }\r\n                var array = data.subarray(offset, endOffset);\r\n                offset += array.length;\r\n                return array;\r\n            }\r\n            function prepareComponents(frame) {\r\n                var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);\r\n                var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);\r\n                for (var i = 0; i < frame.components.length; i++) {\r\n                    component = frame.components[i];\r\n                    var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);\r\n                    var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);\r\n                    var blocksPerLineForMcu = mcusPerLine * component.h;\r\n                    var blocksPerColumnForMcu = mcusPerColumn * component.v;\r\n                    var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);\r\n                    component.blockData = new Int16Array(blocksBufferSize);\r\n                    component.blocksPerLine = blocksPerLine;\r\n                    component.blocksPerColumn = blocksPerColumn;\r\n                }\r\n                frame.mcusPerLine = mcusPerLine;\r\n                frame.mcusPerColumn = mcusPerColumn;\r\n            }\r\n            var offset = 0;\r\n            var jfif = null;\r\n            var adobe = null;\r\n            var frame, resetInterval;\r\n            let numSOSMarkers = 0;\r\n            var quantizationTables = [];\r\n            var huffmanTablesAC = [], huffmanTablesDC = [];\r\n            let fileMarker = binary.readUint16(data, offset);\r\n            offset += 2;\r\n            if (fileMarker !== 65496) {\r\n                throw new JpegError('SOI not found');\r\n            }\r\n            fileMarker = binary.readUint16(data, offset);\r\n            offset += 2;\r\n            markerLoop:\r\n                while (fileMarker !== 65497) {\r\n                    var i, j, l;\r\n                    switch (fileMarker) {\r\n                    case 65504:\r\n                    case 65505:\r\n                    case 65506:\r\n                    case 65507:\r\n                    case 65508:\r\n                    case 65509:\r\n                    case 65510:\r\n                    case 65511:\r\n                    case 65512:\r\n                    case 65513:\r\n                    case 65514:\r\n                    case 65515:\r\n                    case 65516:\r\n                    case 65517:\r\n                    case 65518:\r\n                    case 65519:\r\n                    case 65534:\r\n                        var appData = readDataBlock();\r\n                        if (fileMarker === 65504) {\r\n                            if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {\r\n                                jfif = {\r\n                                    version: {\r\n                                        major: appData[5],\r\n                                        minor: appData[6]\r\n                                    },\r\n                                    densityUnits: appData[7],\r\n                                    xDensity: appData[8] << 8 | appData[9],\r\n                                    yDensity: appData[10] << 8 | appData[11],\r\n                                    thumbWidth: appData[12],\r\n                                    thumbHeight: appData[13],\r\n                                    thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\r\n                                };\r\n                            }\r\n                        }\r\n                        if (fileMarker === 65518) {\r\n                            if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101) {\r\n                                adobe = {\r\n                                    version: appData[5] << 8 | appData[6],\r\n                                    flags0: appData[7] << 8 | appData[8],\r\n                                    flags1: appData[9] << 8 | appData[10],\r\n                                    transformCode: appData[11]\r\n                                };\r\n                            }\r\n                        }\r\n                        break;\r\n                    case 65499:\r\n                        const quantizationTablesLength = binary.readUint16(data, offset);\r\n                        offset += 2;\r\n                        var quantizationTablesEnd = quantizationTablesLength + offset - 2;\r\n                        var z;\r\n                        while (offset < quantizationTablesEnd) {\r\n                            var quantizationTableSpec = data[offset++];\r\n                            var tableData = new Uint16Array(64);\r\n                            if (quantizationTableSpec >> 4 === 0) {\r\n                                for (j = 0; j < 64; j++) {\r\n                                    z = dctZigZag[j];\r\n                                    tableData[z] = data[offset++];\r\n                                }\r\n                            } else if (quantizationTableSpec >> 4 === 1) {\r\n                                for (j = 0; j < 64; j++) {\r\n                                    z = dctZigZag[j];\r\n                                    tableData[z] = binary.readUint16(data, offset);\r\n                                    offset += 2;\r\n                                }\r\n                            } else {\r\n                                throw new JpegError('DQT - invalid table spec');\r\n                            }\r\n                            quantizationTables[quantizationTableSpec & 15] = tableData;\r\n                        }\r\n                        break;\r\n                    case 65472:\r\n                    case 65473:\r\n                    case 65474:\r\n                        if (frame) {\r\n                            throw new JpegError('Only single frame JPEGs supported');\r\n                        }\r\n                        offset += 2;\r\n                        frame = {};\r\n                        frame.extended = fileMarker === 65473;\r\n                        frame.progressive = fileMarker === 65474;\r\n                        frame.precision = data[offset++];\r\n                        const sofScanLines = binary.readUint16(data, offset);\r\n                        offset += 2;\r\n                        frame.scanLines = dnlScanLines || sofScanLines;\r\n                        frame.samplesPerLine = binary.readUint16(data, offset);\r\n                        offset += 2;\r\n                        frame.components = [];\r\n                        frame.componentIds = {};\r\n                        var componentsCount = data[offset++], componentId;\r\n                        var maxH = 0, maxV = 0;\r\n                        for (i = 0; i < componentsCount; i++) {\r\n                            componentId = data[offset];\r\n                            var h = data[offset + 1] >> 4;\r\n                            var v = data[offset + 1] & 15;\r\n                            if (maxH < h) {\r\n                                maxH = h;\r\n                            }\r\n                            if (maxV < v) {\r\n                                maxV = v;\r\n                            }\r\n                            var qId = data[offset + 2];\r\n                            l = frame.components.push({\r\n                                h,\r\n                                v,\r\n                                quantizationId: qId,\r\n                                quantizationTable: null\r\n                            });\r\n                            frame.componentIds[componentId] = l - 1;\r\n                            offset += 3;\r\n                        }\r\n                        frame.maxH = maxH;\r\n                        frame.maxV = maxV;\r\n                        prepareComponents(frame);\r\n                        break;\r\n                    case 65476:\r\n                        const huffmanLength = binary.readUint16(data, offset);\r\n                        offset += 2;\r\n                        for (i = 2; i < huffmanLength;) {\r\n                            var huffmanTableSpec = data[offset++];\r\n                            var codeLengths = new Uint8Array(16);\r\n                            var codeLengthSum = 0;\r\n                            for (j = 0; j < 16; j++, offset++) {\r\n                                codeLengthSum += codeLengths[j] = data[offset];\r\n                            }\r\n                            var huffmanValues = new Uint8Array(codeLengthSum);\r\n                            for (j = 0; j < codeLengthSum; j++, offset++) {\r\n                                huffmanValues[j] = data[offset];\r\n                            }\r\n                            i += 17 + codeLengthSum;\r\n                            (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\r\n                        }\r\n                        break;\r\n                    case 65501:\r\n                        offset += 2;\r\n                        resetInterval = binary.readUint16(data, offset);\r\n                        offset += 2;\r\n                        break;\r\n                    case 65498:\r\n                        const parseDNLMarker = ++numSOSMarkers === 1 && !dnlScanLines;\r\n                        offset += 2;\r\n                        var selectorsCount = data[offset++];\r\n                        var components = [], component;\r\n                        for (i = 0; i < selectorsCount; i++) {\r\n                            const index = data[offset++];\r\n                            var componentIndex = frame.componentIds[index];\r\n                            component = frame.components[componentIndex];\r\n                            component.index = index;\r\n                            var tableSpec = data[offset++];\r\n                            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\r\n                            component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\r\n                            components.push(component);\r\n                        }\r\n                        var spectralStart = data[offset++];\r\n                        var spectralEnd = data[offset++];\r\n                        var successiveApproximation = data[offset++];\r\n                        try {\r\n                            var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, parseDNLMarker);\r\n                            offset += processed;\r\n                        } catch (ex) {\r\n                            if (ex instanceof DNLMarkerError) {\r\n                                sutil.warn(`${ ex.message } -- attempting to re-parse the JPEG image.`);\r\n                                return this.parse(data, { dnlScanLines: ex.scanLines });\r\n                            } else if (ex instanceof EOIMarkerError) {\r\n                                sutil.warn(`${ ex.message } -- ignoring the rest of the image data.`);\r\n                                break markerLoop;\r\n                            }\r\n                            throw ex;\r\n                        }\r\n                        break;\r\n                    case 65500:\r\n                        offset += 4;\r\n                        break;\r\n                    case 65535:\r\n                        if (data[offset] !== 255) {\r\n                            offset--;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        const nextFileMarker = findNextFileMarker(data, offset - 2, offset - 3);\r\n                        if (nextFileMarker && nextFileMarker.invalid) {\r\n                            sutil.warn('JpegImage.parse - unexpected data, current marker is: ' + nextFileMarker.invalid);\r\n                            offset = nextFileMarker.offset;\r\n                            break;\r\n                        }\r\n                        if (!nextFileMarker || offset >= data.length - 1) {\r\n                            sutil.warn('JpegImage.parse - reached the end of the image data ' + 'without finding an EOI marker (0xFFD9).');\r\n                            break markerLoop;\r\n                        }\r\n                        throw new JpegError('JpegImage.parse - unknown marker: ' + fileMarker.toString(16));\r\n                    }\r\n                    fileMarker = binary.readUint16(data, offset);\r\n                    offset += 2;\r\n                }\r\n            this.width = frame.samplesPerLine;\r\n            this.height = frame.scanLines;\r\n            this.jfif = jfif;\r\n            this.adobe = adobe;\r\n            this.components = [];\r\n            for (i = 0; i < frame.components.length; i++) {\r\n                component = frame.components[i];\r\n                var quantizationTable = quantizationTables[component.quantizationId];\r\n                if (quantizationTable) {\r\n                    component.quantizationTable = quantizationTable;\r\n                }\r\n                this.components.push({\r\n                    index: component.index,\r\n                    output: buildComponentData(frame, component),\r\n                    scaleX: component.h / frame.maxH,\r\n                    scaleY: component.v / frame.maxV,\r\n                    blocksPerLine: component.blocksPerLine,\r\n                    blocksPerColumn: component.blocksPerColumn\r\n                });\r\n            }\r\n            this.numComponents = this.components.length;\r\n            return undefined;\r\n        },\r\n        _getLinearizedBlockData(width, height, isSourcePDF = false) {\r\n            var scaleX = this.width / width, scaleY = this.height / height;\r\n            var component, componentScaleX, componentScaleY, blocksPerScanline;\r\n            var x, y, i, j, k;\r\n            var index;\r\n            var offset = 0;\r\n            var output;\r\n            var numComponents = this.components.length;\r\n            var dataLength = width * height * numComponents;\r\n            var data = new Uint8ClampedArray(dataLength);\r\n            var xScaleBlockOffset = new Uint32Array(width);\r\n            var mask3LSB = 4294967288;\r\n            let lastComponentScaleX;\r\n            for (i = 0; i < numComponents; i++) {\r\n                component = this.components[i];\r\n                componentScaleX = component.scaleX * scaleX;\r\n                componentScaleY = component.scaleY * scaleY;\r\n                offset = i;\r\n                output = component.output;\r\n                blocksPerScanline = component.blocksPerLine + 1 << 3;\r\n                if (componentScaleX !== lastComponentScaleX) {\r\n                    for (x = 0; x < width; x++) {\r\n                        j = 0 | x * componentScaleX;\r\n                        xScaleBlockOffset[x] = (j & mask3LSB) << 3 | j & 7;\r\n                    }\r\n                    lastComponentScaleX = componentScaleX;\r\n                }\r\n                for (y = 0; y < height; y++) {\r\n                    j = 0 | y * componentScaleY;\r\n                    index = blocksPerScanline * (j & mask3LSB) | (j & 7) << 3;\r\n                    for (x = 0; x < width; x++) {\r\n                        data[offset] = output[index + xScaleBlockOffset[x]];\r\n                        offset += numComponents;\r\n                    }\r\n                }\r\n            }\r\n            let transform = this._decodeTransform;\r\n            if (!isSourcePDF && numComponents === 4 && !transform) {\r\n                transform = new Int32Array([\r\n                    -256,\r\n                    255,\r\n                    -256,\r\n                    255,\r\n                    -256,\r\n                    255,\r\n                    -256,\r\n                    255\r\n                ]);\r\n            }\r\n            if (transform) {\r\n                for (i = 0; i < dataLength;) {\r\n                    for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {\r\n                        data[i] = (data[i] * transform[k] >> 8) + transform[k + 1];\r\n                    }\r\n                }\r\n            }\r\n            return data;\r\n        },\r\n        get _isColorConversionNeeded() {\r\n            if (this.adobe) {\r\n                return !!this.adobe.transformCode;\r\n            }\r\n            if (this.numComponents === 3) {\r\n                if (this._colorTransform === 0) {\r\n                    return false;\r\n                } else if (this.components[0].index === 82 && this.components[1].index === 71 && this.components[2].index === 66) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n            if (this._colorTransform === 1) {\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n        _convertYccToRgb: function convertYccToRgb(data) {\r\n            var Y, Cb, Cr;\r\n            for (var i = 0, length = data.length; i < length; i += 3) {\r\n                Y = data[i];\r\n                Cb = data[i + 1];\r\n                Cr = data[i + 2];\r\n                data[i] = Y - 179.456 + 1.402 * Cr;\r\n                data[i + 1] = Y + 135.459 - 0.344 * Cb - 0.714 * Cr;\r\n                data[i + 2] = Y - 226.816 + 1.772 * Cb;\r\n            }\r\n            return data;\r\n        },\r\n        _convertYcckToRgb: function convertYcckToRgb(data) {\r\n            var Y, Cb, Cr, k;\r\n            var offset = 0;\r\n            for (var i = 0, length = data.length; i < length; i += 4) {\r\n                Y = data[i];\r\n                Cb = data[i + 1];\r\n                Cr = data[i + 2];\r\n                k = data[i + 3];\r\n                data[offset++] = -122.67195406894 + Cb * (-0.0000660635669420364 * Cb + 0.000437130475926232 * Cr - 0.000054080610064599 * Y + 0.00048449797120281 * k - 0.154362151871126) + Cr * (-0.000957964378445773 * Cr + 0.000817076911346625 * Y - 0.00477271405408747 * k + 1.53380253221734) + Y * (0.000961250184130688 * Y - 0.00266257332283933 * k + 0.48357088451265) + k * (-0.000336197177618394 * k + 0.484791561490776);\r\n                data[offset++] = 107.268039397724 + Cb * (0.0000219927104525741 * Cb - 0.000640992018297945 * Cr + 0.000659397001245577 * Y + 0.000426105652938837 * k - 0.176491792462875) + Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y + 0.000770482631801132 * k - 0.151051492775562) + Y * (0.00126935368114843 * Y - 0.00265090189010898 * k + 0.25802910206845) + k * (-0.000318913117588328 * k - 0.213742400323665);\r\n                data[offset++] = -20.810012546947 + Cb * (-0.000570115196973677 * Cb - 0.0000263409051004589 * Cr + 0.0020741088115012 * Y - 0.00288260236853442 * k + 0.814272968359295) + Cr * (-0.0000153496057440975 * Cr - 0.000132689043961446 * Y + 0.000560833691242812 * k - 0.195152027534049) + Y * (0.00174418132927582 * Y - 0.00255243321439347 * k + 0.116935020465145) + k * (-0.000343531996510555 * k + 0.24165260232407);\r\n            }\r\n            return data.subarray(0, offset);\r\n        },\r\n        _convertYcckToCmyk: function convertYcckToCmyk(data) {\r\n            var Y, Cb, Cr;\r\n            for (var i = 0, length = data.length; i < length; i += 4) {\r\n                Y = data[i];\r\n                Cb = data[i + 1];\r\n                Cr = data[i + 2];\r\n                data[i] = 434.456 - Y - 1.402 * Cr;\r\n                data[i + 1] = 119.541 - Y + 0.344 * Cb + 0.714 * Cr;\r\n                data[i + 2] = 481.816 - Y - 1.772 * Cb;\r\n            }\r\n            return data;\r\n        },\r\n        _convertCmykToRgb: function convertCmykToRgb(data) {\r\n            var c, m, y, k;\r\n            var offset = 0;\r\n            for (var i = 0, length = data.length; i < length; i += 4) {\r\n                c = data[i];\r\n                m = data[i + 1];\r\n                y = data[i + 2];\r\n                k = data[i + 3];\r\n                data[offset++] = 255 + c * (-0.00006747147073602441 * c + 0.0008379262121013727 * m + 0.0002894718188643294 * y + 0.003264231057537806 * k - 1.1185611867203937) + m * (0.000026374107616089405 * m - 0.00008626949158638572 * y - 0.0002748769067499491 * k - 0.02155688794978967) + y * (-0.00003878099212869363 * y - 0.0003267808279485286 * k + 0.0686742238595345) - k * (0.0003361971776183937 * k + 0.7430659151342254);\r\n                data[offset++] = 255 + c * (0.00013596372813588848 * c + 0.000924537132573585 * m + 0.00010567359618683593 * y + 0.0004791864687436512 * k - 0.3109689587515875) + m * (-0.00023545346108370344 * m + 0.0002702845253534714 * y + 0.0020200308977307156 * k - 0.7488052167015494) + y * (0.00006834815998235662 * y + 0.00015168452363460973 * k - 0.09751927774728933) - k * (0.0003189131175883281 * k + 0.7364883807733168);\r\n                data[offset++] = 255 + c * (0.000013598650411385307 * c + 0.00012423956175490851 * m + 0.0004751985097583589 * y - 0.0000036729317476630422 * k - 0.05562186980264034) + m * (0.00016141380598724676 * m + 0.0009692239130725186 * y + 0.0007782692450036253 * k - 0.44015232367526463) + y * (5.068882914068769e-7 * y + 0.0017778369011375071 * k - 0.7591454649749609) - k * (0.0003435319965105553 * k + 0.7063770186160144);\r\n            }\r\n            return data.subarray(0, offset);\r\n        },\r\n        getData({width, height, forceRGB = false, isSourcePDF = false}) {\r\n            if (typeof PDFJSDev === 'undefined' || PDFJSDev.test('!PRODUCTION || TESTING')) {\r\n                sutil.assert(isSourcePDF === true, 'JpegImage.getData: Unexpected \"isSourcePDF\" value for PDF files.');\r\n            }\r\n            if (this.numComponents > 4) {\r\n                throw new JpegError('Unsupported color mode');\r\n            }\r\n            var data = this._getLinearizedBlockData(width, height, isSourcePDF);\r\n            if (this.numComponents === 1 && forceRGB) {\r\n                var dataLength = data.length;\r\n                var rgbData = new Uint8ClampedArray(dataLength * 3);\r\n                var offset = 0;\r\n                for (var i = 0; i < dataLength; i++) {\r\n                    var grayColor = data[i];\r\n                    rgbData[offset++] = grayColor;\r\n                    rgbData[offset++] = grayColor;\r\n                    rgbData[offset++] = grayColor;\r\n                }\r\n                return rgbData;\r\n            } else if (this.numComponents === 3 && this._isColorConversionNeeded) {\r\n                return this._convertYccToRgb(data);\r\n            } else if (this.numComponents === 4) {\r\n                if (this._isColorConversionNeeded) {\r\n                    if (forceRGB) {\r\n                        return this._convertYcckToRgb(data);\r\n                    }\r\n                    return this._convertYcckToCmyk(data);\r\n                } else if (forceRGB) {\r\n                    return this._convertCmykToRgb(data);\r\n                }\r\n            }\r\n            return data;\r\n        }\r\n    };\r\n\r\n    return jpeg.JpegImage = JpegImage;\r\n\r\n});\ndefine('skylark-graphics-image/jpeg-stream',[\r\n    'skylark-langx-objects/shadow',\r\n    'skylark-io-streams/decode-stream',\r\n    \"./jpeg\",\r\n    './jpeg-image'\r\n], function (shadow,DecodeStream, jpeg,JpegImage) {\r\n    'use strict';\r\n\r\n    function JpegStream(stream, maybeLength, dict, params) {\r\n        let ch;\r\n        while ((ch = stream.getByte()) !== -1) {\r\n            if (ch === 255) {\r\n                stream.skip(-1);\r\n                break;\r\n            }\r\n        }\r\n        this.stream = stream;\r\n        this.maybeLength = maybeLength;\r\n        this.dict = dict;\r\n        this.params = params;\r\n        DecodeStream.call(this, maybeLength);\r\n    }\r\n\r\n    JpegStream.prototype = Object.create(DecodeStream.prototype);\r\n\r\n    Object.defineProperty(JpegStream.prototype, 'bytes', {\r\n        get: function JpegStream_bytes() {\r\n            return shadow(this, 'bytes', this.stream.getBytes(this.maybeLength));\r\n        },\r\n        configurable: true\r\n    });\r\n\r\n    JpegStream.prototype.ensureBuffer = function (requested) {\r\n    };\r\n\r\n    JpegStream.prototype.readBlock = function () {\r\n        if (this.eof) {\r\n            return;\r\n        }\r\n        const jpegOptions = {\r\n            decodeTransform: undefined,\r\n            colorTransform: undefined\r\n        };\r\n        const decodeArr = this.dict.getArray('Decode', 'D');\r\n        if (this.forceRGB && Array.isArray(decodeArr)) {\r\n            const bitsPerComponent = this.dict.get('BitsPerComponent') || 8;\r\n            const decodeArrLength = decodeArr.length;\r\n            const transform = new Int32Array(decodeArrLength);\r\n            let transformNeeded = false;\r\n            const maxValue = (1 << bitsPerComponent) - 1;\r\n            for (let i = 0; i < decodeArrLength; i += 2) {\r\n                transform[i] = (decodeArr[i + 1] - decodeArr[i]) * 256 | 0;\r\n                transform[i + 1] = decodeArr[i] * maxValue | 0;\r\n                if (transform[i] !== 256 || transform[i + 1] !== 0) {\r\n                    transformNeeded = true;\r\n                }\r\n            }\r\n            if (transformNeeded) {\r\n                jpegOptions.decodeTransform = transform;\r\n            }\r\n        }\r\n\r\n        //modified by lwf\r\n        //ToDo \r\n        ///if (primitives.isDict(this.params)) {\r\n        if (this.params && this.params.get) {\r\n            const colorTransform = this.params.get('ColorTransform');\r\n            if (Number.isInteger(colorTransform)) {\r\n                jpegOptions.colorTransform = colorTransform;\r\n            }\r\n        }\r\n        const jpegImage = new JpegImage(jpegOptions);\r\n        jpegImage.parse(this.bytes);\r\n        const data = jpegImage.getData({\r\n            width: this.drawWidth,\r\n            height: this.drawHeight,\r\n            forceRGB: this.forceRGB,\r\n            isSourcePDF: true\r\n        });\r\n        this.buffer = data;\r\n        this.bufferLength = data.length;\r\n        this.eof = true;\r\n    };\r\n\r\n    return jpeg.JpegStream = JpegStream;\r\n\r\n});\ndefine('skylark-graphics-image/main',[\r\n\t\"./jpeg\",\r\n\t\"./jpeg-image\",\r\n\t\"./jpeg-stream\"\r\n],function(jpeg){\r\n\treturn jpeg;\r\n});\ndefine('skylark-graphics-image', ['skylark-graphics-image/main'], function (main) { return main; });\n\n"]}